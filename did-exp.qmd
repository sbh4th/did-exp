---
title: "Difference-in-Differences with Heterogenous Treatment Effects"
author: Sam Harper
date: 2023-05-19
format: 
  html:
    code-tools: true
    code-fold: true
---

# Setup 

In this document we aim to provide an overview of the issues and methods for evaluating policy impacts in the context of heterogeneous treatments and staggered treatments.

## Simulated data

```{r sim, cache=TRUE, message=FALSE}
#| code-fold: true

library(tidyverse)

# unit fixed effects (unobserved heterogeneity)
unit <- tibble(
  unit = 1:1000,
  # generate clusters
  state = sample(1:30, 1000, replace = TRUE),
  unit_fe = rnorm(1000, state/10, 1),
  # generate instantaneous treatment effect
  #mu = rnorm(nobs, true_mu, 0.2)
  mu = 2
)

# year fixed effects (first part)
year <- tibble(
  year = 2011:2020,
  year_fe = rnorm(length(year), 0, 1)
)

# Put the clusters into treatment groups
treat_taus <- tibble(
  # sample the clusters randomly
  state = sample(1:30, 30, replace = FALSE),
  # place the randomly sampled states into 1\{t \ge g \}G_g
  cohort_year = sort(rep(c(2014, 2016, 2018), 10))
)

# make main dataset
# full interaction of unit X year 
d <- expand_grid(unit = 1:1000, year = 2011:2020) %>% 
  left_join(., unit) %>% 
  left_join(., year) %>% 
  left_join(., treat_taus) %>% 
  # make error term and get treatment indicators and treatment effects
  # Also get cohort specific trends (modify time FE)
  mutate(error = rnorm(1000*10, 0, 2),
         treat = ifelse((year >= 
           cohort_year)*(cohort_year != 2018), 1, 0),
         # treatment effect = 1 if 2016, 2 if 2014, annually
         mu = ifelse(cohort_year==2016, 1, 2),
         tau = ifelse(treat == 1, mu, 0),
         year_fe = year_fe + 0.5*(year - cohort_year)
  ) %>% 
  # calculate cumulative treatment effects
  group_by(unit) %>% 
  mutate(tau_cum = cumsum(tau)) %>% 
  ungroup() %>% 
  # calculate the dependent variable
  mutate(y = (2020 - cohort_year) + 
           unit_fe + year_fe + tau_cum + error) %>%
  # Relabel 2018 cohort as never-treated
  mutate(cohort_year = ifelse(cohort_year == 2018, Inf, cohort_year))
```


For this example we will use a simulated example.^[This section borrows heavily from Brantly Callaway's excellent [vignette](https://bcallaway11.github.io/did/articles/TWFE.html) on the dangers of using Two-Way Fixed Effects (TWFE) in the context of staggered treatments.] For the time being, we are ignoring covariates. 

We are simulating a staggered treatment setup where 30 'clusters', which could be countries, villages, states, etc., but in this case we will use states ($state = \{1,2,\dots,30\}$), which are randomly assigned into 3 treatment groups depending on the treatment starting year (2014, 2016, never treated). We denote the treatment starting period as $g$ that encompasses the 3 groups (i.e., $g \in \{ 2014, 2016, \text{-Inf}\}$), where $\text{-Inf}$ indicates the never treated group (following Callaway/Sant'Anna here such that $g = \infty$ for a never-treated group). We have 1000 units spread out over the 30 clusters, which could be individuals, schools, hospitals, or some other smaller units $i$, which are randomly assigned to one of the 30 states. Let $G_i$ indicates the group/cohort unit $i$ belongs to, i.e., $G \subseteq \{ 2014, 2016, \infty\}$.

The data generating process (DGP) for the outcome $Y$ is: 
$$Y_{it} = (2020-g) + \alpha_i + \beta_t + \tau_{it} + \epsilon_{it}$$
where $\alpha_i$ are unit (i.e., cluster) fixed effects drawn from $\sim N(\mu_{state}, 1)$ with state-specific mean $\mu_{state} = state/10$, $\beta_t$ are time fixed effects (cohort-specific parallel time-trends) generated as $$\beta_t = 0.5 * (t - g) + \epsilon^{time FE}_t, $$ with $\epsilon^{time FE}_t \sim N(0, 1)$, $\epsilon_{i,t} \sim N(0,2)$ is an idiosyncratic error term. The $\tau_{i,t}$ are the (instantaneous) unit-specific treatment effects at time $t$ generated as 
$$ \tau_{it} = \mu_g \times (t - g + 1)\times 1\{t \ge g \}1\{g\not=\infty \},$$
where $t$ and $g$ are defined as above and $1\{\}$ is a logical operator. We set $\mu_{2014} = 2$, and $\mu_{2016} = 1$. 

So, for example, in 2014 when $G_{2014}$ is first treated, $(t - g + 1)=1$ and the treatment effect is 2. This setup implies heterogeneity: for the group that started treatment in 2014, its average treatment effects evolves with time since first treatment as $2,4,6,\dots$. For the group that started treatment in 2016 the average treatment effect evolves with elapsed time as $1,2,3,\dots$. The treatment effect is zero for the "never-treated" cohort ($g=\infty$). In this case the early-treated group ($g=2014$) benefits more than the later treated group.

Given that each group has same size (on average), the true average treatment effect dynamic across treated groups is $(2+1)/2 = 1.5$ at the time a unit is treated, $2 \times (2+1)/2 = 3$ in the first period after treatment started, etc.

A random sample of 10 rows of the data are shown below:
```{r simtab, results = 'asis', cache=TRUE, message=FALSE}

library(kableExtra)
ds <- sample_n(d,10)
kable(ds, caption = "10 rows of simulated data", digits = 3) %>%
  kable_styling()
```


## Plot of simulated data
Below we show the evolution of $y$ over time for the 3 treatment groups (2014, 2016, untreated). The vertical lines indicate the time of treatment, i.e. $g=t$ for each treated group, and the bold lines show the average evolution of the outcome for each treatment group.

```{r plotsim, cache=TRUE, message=FALSE}
#| code-fold: true

theme_set(theme_classic() + 
            theme(plot.background = element_blank()))

plot <- d %>% 
  ggplot(aes(x = year, y = y, group = unit)) + 
  geom_line(alpha = 1/8, color = "grey") + 
  geom_line(data = d %>% 
    group_by(cohort_year, year) %>% 
    summarize(y = mean(y)),
   aes(x = year, y = y, group = factor(cohort_year),
    color = factor(cohort_year)), linewidth = 2) + 
  labs(x = "", y = "Y",  color = "Treatment group   ") +
  scale_x_continuous(breaks = c(2012, 2014, 2016, 2018, 2020)) +
  geom_vline(xintercept = 2014, color = '#E41A1C', linewidth = 2) + 
  geom_vline(xintercept = 2016, color = '#377EB8', linewidth = 2) + 
  scale_color_brewer(palette = 'Set1') + 
  theme(legend.position = 'bottom',
        #legend.title = element_blank(), 
        axis.title = element_text(size = 14),
        axis.text = element_text(size = 12)) +
  scale_color_manual(labels = c("2014", "2016", "Never-treated"),
                     values = c("#E41A1C", "#377EB8", "#4DAF4A")) +
  ggtitle("Simulated data with heterogeneous treatment effect dynamics across cohorts \n and with a never-treated group")+
  theme(plot.title = element_text(hjust = 0.5, size=12))

plot 
```

# Estimating treatment effects
Next we show various ways of estimating the treatment effects, starting with the standard two-way fixed effects (TWFE) that has been standard in many diff-in-diffs analyses. 

## TWFE (average)

The basic model is estimated as:

$$Y_{it} = \alpha_i + \beta_t + \gamma D_{it} + \varepsilon_{it}$$ 
where $D_{i,t}$ is a time-varying treatment dummy variable that takes value one if a unit $i$ is treated at time $t$, and $\alpha_{i}$ and $\beta_{t}$ are fixed effects for unit and time, respectively. We implement this below using the `fixest` package and cluster the standard errors at the state level. 


```{r est, message=FALSE}

library(fixest)
library(fastDummies)
library(modelsummary)
library(marginaleffects)
library(did)
```

## TWFE (dynamic)
Many analyses using TWFE also typically implement an 'event study' type analysis as a robustness check, both to see how the treatment effect may evolve over time in the post period and to see whether there may be some evidence of non-parallel trends in the pre-treatment period. We can implement the event-study type model as:
$$Y_{it} = \alpha_i + \beta_t + \sum_{k\neq-1} \gamma_{k} D_{it} + \varepsilon_{it}$$ 
where $k$ indicates time indicators relative to first treatment (i.e., $k=-2$ means 2 periods prior to treatment) and $\gamma_{k}$ are the coefficients on the relative time indicators. To avoid collinearity we exclude one period, which is typically the period just before first treatment ($k=-1$). 

Below is a table showing the estimated effects from the TWFE and event-study models:

```{r es, cache=TRUE}

# Estimate TWFE
twfe = fixest::feols(
  y ~ treat | state + year,
  data = d,
  vcov = ~state
)

# first make dummy columns for relative time
data <- d %>% 
  # make dummies
  mutate(rel_year = year - cohort_year) %>% 
  dummy_cols(select_columns = "rel_year") 

# estimate the model
twfe_event = fixest::feols(
  y ~ `rel_year_-5` + `rel_year_-4` + `rel_year_-3` + 
      `rel_year_-2` + `rel_year_0` + `rel_year_1` + 
    `rel_year_2` + `rel_year_3` + `rel_year_4` + 
    `rel_year_5` | state + year,
  data = data,
  vcov = ~state
)

rename_rt <- function(old_names) {
  new_names <- gsub("rel_year_", "Relative time: ", old_names)
  setNames(new_names, old_names)
}

modelsummary(list("TWFE" = twfe, 
  "TWFE:Event study" = twfe_event),
  coef_rename = rename_rt,
  gof_omit ='DF|Deviance|R2|AIC|BIC|Log.Lik|ICC|RMSE')
```

How well do the event study coefficients map on to our true estimates from the DGP? Below we show a plot of the true effects based on the simulated data, as well as the estimates from the event study. The answer is: not well. Not only are the TWFE event-study estimate incorrect in the post period, they also suggest some evidence for non-parallel trends in the pre-period. [some text on intuition for this would be helpful here].

```{r esp, cache=TRUE, message = FALSE, warning=FALSE}
# plot of estimates
pt <- get_estimates(twfe_event) %>%
  select(term, estimate, conf.low, conf.high) %>%
  mutate(t = c(-5:-2, 0:5)) %>%
  bind_rows(tibble(t = -1, estimate = 0, 
    conf.low = 0, conf.high = 0, term = "rel_year_-1")) %>%
  mutate(true_tau = ifelse(t >= 0, ((t + 1) * 1.5 ), 0))

colors <- c("True Effect" = "red", "Estimated Effect" = "blue")

plot_es <- pt %>%
  ggplot(aes(x = t, y = estimate)) + 
    geom_point(color = "blue", size = 3) +
    geom_line(aes(color = 'Estimated Effect'), linewidth = 1) +
    geom_linerange(aes(ymin = conf.low, ymax = conf.high), 
    color = "blue", linewidth = 2, alpha = 0.3) +
    geom_line(aes(x = t, y = true_tau, color = 'True Effect'), 
              linetype = "dashed", linewidth = 2) + 
    geom_hline(yintercept = 0, linetype = "dashed") + 
    scale_x_continuous(breaks = -5:5) + 
    labs(x = "Relative Time", y = "Estimate") +
    ggtitle("TWFE event-study regression estimates") +
    scale_color_manual(values = colors) + theme_classic() +
    theme(legend.position = 'bottom',
      legend.title = element_blank(), 
      axis.title = element_text(size = 14),
      axis.text = element_text(size = 12),
      plot.title = element_text(hjust = 0.5, size=12),
      plot.background = element_blank())
plot_es
```

## Callaway-Sant'Anna

To avoid the problems with the TWFE specification above, we can instead use the approach recently developed by Callaway and Sant’Anna that estimates the average treatment effect on the treated ($ATT$) for each treated group $g$ at each time $t$, i.e., $ATT(g,t)$, where groups are defined according to when they were first treated. The group-time specific estimates of each $ATT(g,t)$ are estimated via regression on *subsets* of the data for each group and time periods covering pre- and post-intervention, using the following specification:

$$Y_{it} = \beta_{0}^{gt} + \beta_{1}^{gt}G + \beta_{2}^{gt}T + \beta_{3}^{gt}(G\times T) + \varepsilon^{gt} $$

where $G$ and $T$ refer to indicators for group and time period and $\beta_{3}^{gt}$ is the $ATT(g,t)$ for each group at a given time. Treated groups are compared to not yet treated groups to estimate group-time specific $ATTs$ , which can be combined to estimate the overall effect of the intervention, as well as dynamic treatment effects. 

```{r cs, message=FALSE, warning=FALSE}
# Callaway-Sant'Anna
cs <- did::att_gt(yname = "y", 
                  tname = "year",
                  idname = "unit",
                  gname = "cohort_year",
                  control_group= "notyettreated",
                  bstrap = TRUE,
                  clustervars = "state",
                  data = d,
                  print_details = FALSE)

cs_simple <- did::aggte(cs, type = "simple")
cs_event <- did::aggte(cs, type = "dynamic")

# wrangle aggregate ATTs for model summary table
ti <- data.frame(
  term = "treat",
  estimate = cs_simple$overall.att,
  std.error = cs_simple$overall.se)

gl <- data.frame()

cs_avg <- list(tidy = ti, glance = gl)
class(cs_avg) <- "modelsummary_list"

modelsummary(list("TWFE" = twfe, "Callaway" = cs_avg),
  gof_omit ='_*')
```

